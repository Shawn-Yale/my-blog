---
title: 二分图（从入门到入土）
date: 2025-05-19 18:59:07
tags:
    - 二分图
categories:
    - 算法笔记
---

# 二分图判定
## 什么是二分图？
**二分图：** 节点由两个集合组成，且两个集合内部没有边的图。换言之，存在一种方案，将节点划分成满足以上性质的两个集合。
—— OI-wiki
![](/images/二分图示例.png)
如图，在一个图中，如果能把点分为**两个顶点集**，使**每个集合中，没有两个点有连边**。
也就是说，**边只会连接两个点集**。
## 如何判定二分图？
**存在定理：一张无向图是二分图,当且仅当图中不存在奇环(长度为奇数的环)**
**根据该定理**，可以以染色法进行二分图的判定。主体思想为：尝试用黑白两种颜色标记图中的结点，当一个结点被标记后，它的所有相邻结点应该被标记与它相反的颜色。若标记过程中产生冲突，则说明图中存在奇环。二分图染色一般基于DFS实现，时间复杂度为 $\mathcal O(n+m)$
**伪代码如下：**
```cpp
void dfs(int x,int color){
	赋值v[x] <-- color
	对于与x相连的每条无向边(x,y)
	if v[y]=0 then
		dfs(y,3-color)
	else if v[y]=color then 
		判定无向图不是二分图,算法结束
	}

在主函数中
	for i <-- 1 to n
		if(v[i]=0)then dfs(i,1)
	判定无向图是二分图
```
## [P1330 封锁阳光大学](https://www.luogu.com.cn/problem/P1330)(二分图判定)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 1e4 + 10, M = 2e5 + 10;
int n, m, h[N], e[M], ne[M], idx, col[N];
array<int, 2> sum;

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

void dfs(int u, int vis){
    col[u] = vis;
    sum[vis & 1]++;
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(col[v]){
            if(col[v] == col[u]){
                cout << "Impossible" << endl;
                exit(0);
            }
        }else dfs(v, 3 - vis);
    }
}

void solve(){
    cin >> n >> m;
    fill(h + 1, h + n + 1, -1);
    for(int i = 1; i <= m; i++){
        int a, b; cin >> a >> b;
        add(a, b);
        add(b, a);
    }
    int ans = 0;
    for(int i = 1; i <= n; i++){
        sum = {0, 0};
        if(!col[i]) dfs(i, 1);
        ans += min(sum[0], sum[1]);
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```

## [P1525 [NOIP 2010 提高组] 关押罪犯](https://www.luogu.com.cn/problem/P1525)(二分答案+ 二分图判定)(可用并查集)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 2e4 + 10, M = 2e5 + 10;
int n, m, a[M], b[M], c[M], id[M];
int h[N], e[M], ne[M], idx;
int col[N];
int ok;

void add(int u, int v){
    e[idx] = v;
    ne[idx] = h[u];
    h[u] = idx++;
}

void dfs(int u, int vis){
    col[u] = vis;
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(col[v]){
            if(col[u] == col[v])
                return void(ok = 0);
        }else dfs(v, 3 - vis);
    }
}

bool check(int pos){
    idx = 0;
    fill(h + 1, h + n + 1, -1);
    for(int i = pos; i <= m; i++){
        int j = id[i];
        add(a[j], b[j]);
        add(b[j], a[j]);
    }
    ok = 1;
    fill(col + 1, col + n + 1, 0);
    for(int i = 1; i <= n && ok; i++)
        if(!col[i]) dfs(i, 1);
    return ok;
}

void solve(){
    cin >> n >> m;
    for(int i = 1; i <= m; i++){
        cin >> a[i] >> b[i] >> c[i];
        id[i] = i;
    }
    sort(id + 1, id + m + 1, [&](int i, int j){
        return c[i] < c[j];
    });
    int l = 1, r = m + 1;
    while(l < r){
        int mid = (l + r) >> 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    cout << c[id[l - 1]] << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [CF19E. Fairy](https://codeforces.com/contest/19/problem/E)(树上差分 + 二分图判定)(2900)
**解决的问题： 在一个无向图中，找出所有「删除后能使图变成二分图（无奇环）」的边。**
**时间复杂度：**
- 建图 + DFS：$\mathcal O(n + m)$
- 最后枚举所有边判断：$\mathcal O(m)$
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define vi vector<int>
const int N = 2e5 + 10, M = 4e5 + 10;
int n, m, h[N], e[M], ne[M], eid[M], idx;
// eid[idx]: 当前有向边对应的「原始边编号」（1…m）

void add(int a, int b, int id){
    eid[idx] = id;
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

int dep[N], p[N], fl[N], c1[N], c2[N], cnt_odd = 0;
// —— DFS 及差分数组准备 ——
// dep[u]: 深度（根节点深度为 1）
// p[u]: 进入 u 时所用的「原始边编号」
// fl[id]: 标记原始编号为 id 的边是否为树边
// c1[id], c2[id]: 差分数组，分别统计「参与奇环」和「参与偶环」的次数
// cnt_odd: 全局奇环总数


/*
DFS 遍历，构造生成树并统计基环奇偶性
u   当前节点
fa  父节点
pre 从 fa → u 使用的有向边下标（根节点传 -1）
 */
void dfs(int u, int fa, int pre){
    dep[u] = dep[fa] + 1;
    if(pre != -1) p[u] = eid[pre]; // 记录进 u 时的「原始边编号」
    for(int i = h[u]; ~i; i = ne[i]){ // 遍历 u 的所有出边
        int v = e[i];
        if(i == (pre ^ 1)) continue; // 跳过回到父节点时的那条反向边
        if(!dep[v]){ // 树边  
            dfs(v, u, i);
            fl[eid[i]] = 1; // 标记这条原始边为树边
            // 把子树传上来的差分信息累加到「进 u 的那条树边」上
            if(pre != -1){
                c1[p[u]] += c1[eid[i]];
                c2[p[u]] += c2[eid[i]];
            }
        }else if(dep[u] > dep[v]){
            // —— 回边 —— 构成一个基环
            int len = dep[u] - dep[v] + 1;
            if(len & 1){ // 奇环
                c1[eid[i]]++; // 回边自身 +1
                if(pre != -1) c1[p[u]]++; // 从 u 往上差分
                if(p[v]) c1[p[v]]--; // 到 v 停止
                cnt_odd++;
            }else{ // 偶环
                c2[eid[i]]++;
                if(pre != -1) c2[p[u]]++;
                if(p[v]) c2[p[v]]--;
            }
        }
    }
}

void solve(){
    cin >> n >> m;
    fill(h + 1, h + n + 1, -1);
    for(int i = 1; i <= m; i++){
        int u, v; cin >> u >> v;
        add(u, v, i); add(v, u, i);
    }
    for(int i = 1; i <= n; i++){
        if(!dep[i]) dfs(i, 0, -1);
    }
    vi ans;
    if(cnt_odd == 0){
        // 原图已是二分图：任意一条边都可删除
        for(int i = 1; i <= m; i++)
            ans.emplace_back(i);
    }else{
        // 存在奇环，按树边/回边条件筛选
        for(int i = 1; i <= m; i++){
            if(fl[i]){
                // 树边：必须切断所有奇环且不能破坏任何偶环
                if(c1[i] == cnt_odd && c2[i] == 0)
                    ans.emplace_back(i);
            }else{
                // 回边：仅当全局只有这 1 条奇环，且它就是这条边
                if(cnt_odd == 1 && c1[i] == 1)
                    ans.emplace_back(i);
            }
        }
    }
    cout << ans.size() << endl;
    for(auto x : ans) cout << x << " \n"[x == ans.back()];
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```

# 二分图最大匹配
## 二分图最大匹配是什么？
**匹配：** 在图论中，一个「匹配」是一个边的集合，其中任意两条边都没有公共顶点。
**二分图最大匹配**，顾名思义就是一个点**最多只能有与其有关系的一条边**被选中，问最多能选择多少条边
换作夫妻匹配问题，就是问在**一夫一妻制**下最多能找到多少对~~海王~~夫妻
著名的解决二分图最大匹配问题的算法为**匈牙利算法**，也可以借助**最大流/最小割**模型解决这类问题
## 匈牙利（Hungary）算法
**求二分图最大匹配的一般是用匈牙利算法** ~~，因为好写~~。
### 引入
**匈牙利算法**是基于**深度优先搜索**一遍一遍搜索**增广路**的存在性来增加匹配对数的
首先，要先知道一个叫**增广路**的东西。

> 若 P 是图 G 中一条连通两个未匹配顶点的路径，并且属于 M 的边和不属于 M 的边(即已匹配和待匹配的边)在 P 上交替出现，则称 P 为相对于 M 的一条增广路径（举例来说，有 A、B 集合，增广路由 A 中一个点通向B中一个点，再由 B 中这个点通向 A 中一个点……交替进行）。 ——百度百科

假设当前存在一条边 (u,v)，我们希望这条边加入匹配。
首先如果选的这条边满足 (u,v) 都尚未匹配，那我们可以直接把这条边加入答案，这样会使匹配数加一。
但如果两个点存在一个点有匹配另一个点，不妨假设点 u 除了这条边还存在另一个匹配 (u,v′)。这意味着点 u 被选了两次。于是我们希望点 v′ 能不选。
于是如果点 v′ 所连出的边除去 (u,v′) 外依然存在一条边 (v′,v′′) 没被选，那就可以扔掉 (u,v′) 加入 (v′,v′′)。如果 v′′ 尚未有匹配点，那么就直接结束该过程。否则再对 v′′ 做类似 u 的判断。
这意味着我们最后找出来的路径一定是一条不是匹配的边，一条是匹配的边交替出现。以最后一点尚未匹配作为结束条件。
根据上面描述的过程，最后我们只需要反转这些边的状态，即匹配的变成非匹配边，非匹配边变成匹配边。
可以发现这就是找增广路的过程，这说明我们只要找一条增广路，然后反转上面的点即可。这意味着若存在增广路，那么答案会增加一，否则答案不会变。
那我们一直找增广路，当不存在增广路时，得到的结果就是最大匹配了。

**生动形象的描述：**
我们将问题看作相亲现场，每个 $U$ 集合的人排队寻找 $V$ 集合里的对象
假设是男生排队找女生，基于这个"时间"顺序，假设前面的男生已经匹配了一些
下一个男生 $a$ 进来匹配，算法便会遍历一遍他认识的女生（与他有关系的 $V$ 集内的点）
如果发现当前遍历到的女生还没有被其他男生匹配，那非常好，就直接把这个女生匹配给男生 $a$
如果发现已经被其他男生 $b$ 给~~绿~~匹配了，那算法会尝试去和那个男生 $b$ 沟通，询问能否让他换一个（？）
算法便会来到那个男生 $b$ 那里，重新遍历一遍他认识的女生，看看能否找到其他能够匹配的女生（寻找增广路/套娃）
如果可以，那么男生 $b$ 便会与新找到的女生匹配，顺利成章的，原来与男生 $b$ 匹配的女生就可以和男生 $a$ 匹配啦
如果不行，那么男生 $a$ 就没这个机会了，尝试下一个吧（继续遍历），实在不行（遍历完了）单着挺好的
就以这样的方法一直搜索，直到所有男生（$U$ 集）该匹配的都匹配完了，就能得到最大匹配数了
### 代码实现
下面使用 $vector \ G$ 来储存每个男生认识的女生
使用 $int \ match$ 来储存每个女生当前匹配的男生的编号（没匹配则为 $0$）
如上面所说，我们需要遍历每个 $U$ 集的男生去尝试匹配
对于每个男生 $p$ ，要遍历一遍他认识的女生
```cpp
for(int i : G[p])
```
此时女生的编号便以 $i$ 来表示
如果当前的女生没被匹配到，自然可以直接让她与当前的男生 $p$ 进行匹配
但如果已经被匹配过，则尝试让匹配她的那个男生去再找找看其他女生（开始套娃），如果返回 $true$ 也可以正常匹配
```cpp
for(int i : G[p]){
    if(!match[i] || hungary(match[i])){
        match[i] = p;
        return true;
    }
}
```
那么对于这个套娃应该如何处理呢
每次搜索时都假设自己没匹配到，那么上面的代码可以满足搜索的功能
但是可以发现一个问题，从第二层寻找增广的搜索开始，$match$ 数组的值是没有变的（也就是说在寻找到新的女生之前，第一层遍历到的那个女生的 $match$ 依旧是第二层的这个男生）
第二层这个男生一定还会再找到这个女生，于是便会开始无限套娃死循环 $Runtime \ Error$
所以我们需要新开一个数组 $vis$ 来储存当前这一遍搜索是否已经让某个男生找过增广路了（找过了就不用再找了反正也找不到，正在找的话就直接退出防止套娃）
至此这个搜索函数算是完整了
```cpp
bool hungary(int p){
    if(vis[p]) //防止套娃
        return false;
    vis[p] = true; //访问标记
    for(int i : G[p]){
        if(!match[i] || hungary(match[i])){
            match[i] = p;
            return true; //海王在世
        }
    }
    return false; //单身贵族
}
```
但是先这样使用 $bool \ vis$ 的话有个弊端，也就是每次搜索某个男生时都要清空一次，时间耗费总和挺大的
所以我们可以在传值的时候再加个趟数 $op$ ，表示这是第几趟匹配了（或者表示这一趟主要是为了让哪个男生找女生），这样使用 $int \ vis$ 便可以做到不清空解决问题
```cpp
bool hungary(int p,int op){ //新增传值
    if(vis[p] == op) //依据趟数防止套娃
        return false;
    vis[p] = op; //标记这一趟是否访问过
    for(int i : G[p]){
        if(!match[i] || hungary(match[i], op)){
            match[i] = p;
            return true;
        }
    }
    return false;
}
```

## [P3386 【模板】二分图最大匹配 ](https://www.luogu.com.cn/problem/P3386)(二分图最大匹配)
**注意每次 DFS 之前，清空 vis**
如果不在每次新的 $u$ 发起 DFS 之前清空 $vis$，那么上一次为另一个左点匹配过程中标记过的右点就会被“永远跳过”
**时间复杂度： 每次 DFS 最坏会遍历所有边，次数为 $n$，因此  $\mathcal O(n⋅e)$。**
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 5e2 + 10, M = 5e4 + 10;
int n, m, k, ans;
int h[N], e[M], ne[M], idx;
int vis[N], match[N];

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v]) continue;
        vis[v] = 1;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> n >> m >> k;
    fill(h + 1, h + n + 1, -1);
    for(int i = 1; i <= k; i++){
        int a, b; cin >> a >> b;
        add(a, b);
    }
    for(int i = 1; i <= n; i++){
        memset(vis, 0, sizeof vis);
        // 注意清空 vis
        if(dfs(i)) ans++;
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [AcWing372. 棋盘覆盖](https://www.acwing.com/file_system/file/content/whole/index/content/3923/)(二分图最大匹配)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define pii pair<int, int>
const int N = 100 + 10;
int n, m, a[N][N], vis[N][N];
// a[i][j] = 1 表示 (i,j) 禁止放置
pii match[N][N];
int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};

bool dfs(int x, int y){
    for(int i = 0; i < 4; i++){
        int nx = x + dx[i], ny = y + dy[i];
        if(nx < 1 || nx > n || ny < 1 || ny > n) continue;
        if(a[nx][ny] || vis[nx][ny]) continue;
        vis[nx][ny] = 1;
        if(match[nx][ny] == make_pair(-1ll, -1ll) ||
            dfs(match[nx][ny].first, match[nx][ny].second)){
                match[nx][ny] = {x, y};
                return true;    
            }
    }
    return false;
}


void solve(){
    cin >> n >> m;
    for(int i = 1; i <= m; i++){
        int x, y; cin >> x >> y;
        a[x][y] = 1;
    }
    memset(match, -1, sizeof match);
    int ans = 0;
    
    // 遍历所有格子，将 (i+j)%2==1 的作为“左侧”节点尝试匹配
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            if(((i + j) & 1) && !a[i][j]){
                memset(vis, 0, sizeof vis);
                if(dfs(i, j)) ans++;
            }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [P1894 [USACO4.2] 完美的牛栏The Perfect Stall](https://www.luogu.com.cn/problem/P1894)(二分图最大匹配)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 210, M = 4e4 + 10;
int n, m, h[N], e[M], ne[M], idx;
int vis[N], match[N];

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v]) continue;
        vis[v] = 1;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> n >> m;
    memset(h, -1, sizeof h);
    for(int i = 1; i <= n; i++){
        int x; cin >> x;
        for(int j = 1; j <= x; j++){
            int k; cin >> k;
            add(i, k);
        }
    }
    int ans = 0;
    for(int i = 1; i <= n; i++){
        memset(vis, 0, sizeof vis);
        if(dfs(i)) ans++;
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [P2071 座位安排](https://www.luogu.com.cn/problem/P2071)(二分图最大匹配)
N 排座位，2N 个人，每个人有四个座位可选，所以最多 8N 条线
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 4e3 + 10, M = 16e3 + 10;
int n, h[N], e[M], ne[M], idx;
int vis[N], match[N];

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v]) continue;
        vis[v] = 1;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> n;
    memset(h, -1, sizeof h);
    for(int i = 1; i <= 2 * n; i++){
        int x, y; cin >> x >> y;
        add(i, 2 * x); add(i, 2 * x - 1);
        add(i, 2 * y); add(i, 2 * y - 1);
    }
    int ans = 0;
    for(int i = 1; i <= 2 * n; i++){
        memset(vis, 0, sizeof vis);
        if(dfs(i)) ans++;
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```

## [P10937 車的放置](https://www.luogu.com.cn/problem/P10937)(二分图最大匹配)
 **题意：** 除去禁止放置的点，最多存在多少个互相不同行同列的点
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 210, M = 4e4 + 10;
int n, m, t;
int h[N], e[M], ne[M], idx;
int vis[N << 1], match[N << 1], stamp;
int g[N][N];

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    memset(h, -1, sizeof h);
    cin >> n >> m >> t;
    for(int i = 1; i <= t; i++){
        int x, y; cin >> x >> y;
        g[x][y] = 1;
    }
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            if(!g[i][j]) add(i, j + N);
    int ans = 0;
    for(int i = 1; i <= n; i++){
        stamp++;
        if(dfs(i)) ans++;
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```

## [P1129 [ZJOI2007] 矩阵游戏](https://www.luogu.com.cn/problem/P1129)(二分图最大匹配)
**通过手动模拟，可以发现：** 无论经过多少次交换，原本存在于该行的元素一定还在该行（只是顺序不同），原本存在于该列上的元素一定还在该列（只是顺序不同）。
**所以题目可转化为：** 能不能找到 $n$ 个互相不同行不同列的点。
那我们可以建一个二分图，左边是行，右边是列，如果一个点是黑色的，就从左边连右边，求最大匹配，看是否为 $n$ 。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 200 + 10, M = 4e4 + 10;
int n, h[N], e[M], ne[M], idx;
int vis[N], match[N];

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v]) continue;
        vis[v] = 1;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> n;
    idx = 0; // 注意初始化，清空
    memset(h, -1, sizeof h);
    memset(match, 0, sizeof match);
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++){
            int x; cin >> x;
            if(x) add(i, j);
        }
    int ans = 0;
    for(int i = 1; i <= n; i++){
        memset(vis, 0, sizeof vis);
        if(dfs(i)) ans++;
    }
    cout << (ans == n ? "Yes" : "No") << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    cin >> T;
    while(T--) solve();
    return 0;
}
```

## [P2055 [ZJOI2009] 假期的宿舍](https://www.luogu.com.cn/problem/P2055)(二分图最大匹配)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 60, M = 25e2 + 10;
int n, vec[N], ok[N], h[N], e[M], ne[M], idx;
// vec 记录是否本校学生 1是/0不是
// ok 记录是否回家 1回/0不回
int vis[N], match[N];

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v]) continue;
        vis[v] = 1;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> n;
    idx = 0;
    memset(h, -1, sizeof h);
    memset(match, 0, sizeof match);
    memset(ok, 0, sizeof ok);
    int goal = 0; // 需要的床的数量
    for(int i = 1; i <= n; i++) cin >> vec[i];
    for(int i = 1; i <= n; i++){
        cin >> ok[i];
        if((vec[i] && !ok[i]) || !vec[i]) goal++;
    }
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            int x; cin >> x;
            if(vec[i] && ok[i]) continue;
            // 跳过本校回家的学生(不需要床的人)
            if(j == i && vec[i]) add(i, i);
            // 本校学生可以睡自己的床
            if(x && vec[j]) add(i, j);
            // 睡的床必须是本校学生的
        }   
    }
    int ans = 0;
    for(int i = 1; i <= n; i++){
        if((vec[i] && !ok[i]) || !vec[i]){
            // 如果这个人需要床，才会尝试搜索
            memset(vis, 0, sizeof vis);
            if(dfs(i)) ans++;
        }
    }
    cout << (ans == goal ? "^_^" : "T_T") << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    cin >> T;
    while(T--) solve();
    return 0;
}
```

## [P1640 [SCOI2010] 连续攻击游戏](https://www.luogu.com.cn/problem/P1640)(二分图最大匹配)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 1e4 + 10, M = 1e6 + 10;
int n, h[N], e[M << 1], ne[M << 1], idx;
int vis[N], match[M], stamp;
// stamp作为时间戳，节省memset vis的时间复杂度

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> n;
    memset(h, -1, sizeof(h));
    for(int i = 1; i <= n; i++){
        int x, y; cin >> x >> y;
        add(x, i); add(y, i);
    }
    int ans = 0;
    for(int i = 1; i <= 1e4; i++){
        stamp++;
        if(dfs(i)) ans++;
        else break; // 找不到匹配的就退出
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [P2319 [HNOI2006] 超级英雄](https://www.luogu.com.cn/problem/P2319)(二分图最大匹配)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 1e3 + 10, M = 2e3 + 10;
int n, m, h[N], e[M], ne[M], idx;
int vis[N], match[N], stamp, ok[N];
// stamp作为时间戳，节省memset vis的时间复杂度
// ok[i]: 记录问题i 使用的锦囊妙计的编号

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            ok[u] = v;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> n >> m;
    memset(h, -1, sizeof h);
    for(int i = 1; i <= m; i++){
        int x, y; cin >> x >> y;
        add(i, x); add(i, y);
    }
    int ans = 0;
    for(int i = 1; i <= m; i++){
        stamp++;
        if(dfs(i)) ans++;
        else break;
    }
    cout << ans << endl;
    for(int i = 1; i <= ans; i++)
        cout << ok[i] << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [P2756 飞行员配对方案问题](https://www.luogu.com.cn/problem/P2756)(二分图最大匹配)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 110, M = 2510;
int n, m, h[N], e[M], ne[M], idx;
int vis[N], match[N], ok[N], stamp;
// ok[i]: 记录外籍飞行员i的搭档编号

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            ok[u] = v;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> m >> n;
    memset(h, -1, sizeof h);
    int x, y;
    while(cin >> x >> y, x != -1 && y != -1){
        add(x, y);
    }
    int ans = 0;
    for(int i = 1; i <= m; i++){
        stamp++;
        if(dfs(i)) ans++;
    }
    cout << ans << endl;
    for(int i = 1; i <= n; i++)
        if(ok[i]) cout << i << ' ' << ok[i] << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [P2526 [SHOI2001] 小狗散步](https://www.luogu.com.cn/problem/P2526)(二分图最大匹配)(省选/NOI−)
**这道题的关键在构图**
根据题意得知，每次狗在主人相遇之前最多去一个景点。那我们不妨枚举所有的景点，判断狗从上一个相遇点出发，经过这个景点，最后是否比主人先到达下一个相遇点。
如果先到达，那我们就把上一个相遇点与这个景点连一条边。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define pii pair<int, int>
const int N = 210, M = 1e4 + 10;
int n, m, h[N], e[M], ne[M], idx;
int vis[N], match[N], stamp, ok[N];
// ok[i]: 从相遇点离开后去的景点下标
pii cnt[N];
// cnt记录每个点的坐标

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            ok[u] = v;
            return true;
        }
    }
    return false;
}

long double calc(pii a, pii b){
    return sqrtl((a.first - b.first) * (a.first - b.first)
        + (a.second - b.second) * (a.second - b.second));
}

void solve(){
    cin >> n >> m;
    memset(h, -1, sizeof h);
    for(int i = 1; i <= n; i++){
        int x, y; cin >> x >> y;
        cnt[i] = {x, y};
    }
    for(int i = 1; i <= m; i++){
        int x, y; cin >> x >> y;
        cnt[n + i] = {x, y};
        for(int j = 1; j < n; j++){
            if(2 * calc(cnt[j], cnt[j + 1]) >= 
                calc(cnt[j], cnt[n + i]) + calc(cnt[j + 1], cnt[n + i]))
                add(j, n + i);
        }
    }
    int ans = 0; // 最多可以参观多少个景点
    for(int i = 1; i <= n; i++){
        stamp++;
        if(dfs(i)) ans++;
    }
    cout << n + ans << endl;
    for(int i = 1; i <= n; i++){
        cout << cnt[i].first << ' ' << cnt[i].second << " \n"[i == n];
        if(ok[i]) cout << cnt[ok[i]].first << ' ' << cnt[ok[i]].second << ' ';
    }
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [P1963 [NOI2009] 变换序列](https://www.luogu.com.cn/problem/P1963)(二分图最大匹配)(字典序最小匹配)(省选/NOI−)
**本题关键点：字典序最小匹配**
1. 建图：
```cpp
int y1 = (n + i - x) % n;
int y2 = (n + i + x) % n;
```
代表两个合法目标点。注意有可能 `y1 == y2`，此时只加一条边。
为了使得匹配顺序优先匹配编号小的右侧点（保证字典序小），在加边的时候倒过来加：
```cpp
if(y1 < y2) swap(y1, y2); // 把小编号的边最后加上，先被访问
add(i, y1);
add(i, y2);
```
2. 字典序最小匹配的 dfs 顺序：
```cpp
for(int i = n - 1; i >= 0; i--)
dfs(i);
```
倒序处理左侧点，这样编号小的点优先匹配目标编号小的点。

**完整代码：**
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 1e4 + 10, M = 2e4 + 10;
int n, h[N], e[M], ne[M], idx;
int vis[N], match[N], ok[N], stamp;

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(match[v] == -1 || dfs(match[v])){
            match[v] = u;
            ok[u] = v;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> n;
    memset(h, -1, sizeof h);
    memset(match, -1, sizeof match);
    // 因为此题下标从 0 开始，所以未匹配时初始化为 -1

    for(int i = 0; i < n; i++){
        int x; cin >> x;
        int y1 = (n + i - x) % n;
        int y2 = (n + i + x) % n;
        if(y1 == y2) add(i, y1);
        else{
            if(y1 < y2) swap(y1, y2);
            // 确保先add编号大的，这样在遍历时就会从编号小的开始
            add(i, y1);
            add(i, y2);
        }        
    }
    int ans = 0;
    for(int i = n - 1; i >= 0; i--){
	    // 逆序遍历，确保字典序最小
        stamp++;
        if(dfs(i)) ans++;
    }
    if(ans != n) return void(cout << "No Answer" << endl);
    for(int i = 0; i < n; i++)
        cout << ok[i] << " \n"[i == n - 1];
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```

## [P2763 试题库问题](https://www.luogu.com.cn/problem/P2763)(二分图最大匹配)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define arr2 array<int, 2>
const int N = 1e3 + 10, M = 1e6 + 10;
int k, n, h[N], e[M], ne[M], idx;
int vis[N], match[N], stamp, ok[N];
arr2 cnt[25];
// 将每个类型按需要的题量拆点
// cnt[i]: 记录需要的 i 类型的题拆完点之后的下标
// 二分图左侧: 每个类型需要的题
// 二分图右侧: 每个题的初始下标

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            ok[u] = v;
            return true;
        }
    }
    return false;
}

void solve(){
    memset(h, -1, sizeof h);
    cin >> k >> n;

    // 拆点
    int cur = 1;
    for(int i = 1; i <= k; i++){
        int x; cin >> x;
        cnt[i] = {cur, cur + x - 1};
        cur += x;
    }

    // 连边
    for(int i = 1; i <= n; i++){
        int x; cin >> x;
        for(int j = 1; j <= x; j++){
            int id; cin >> id;
            for(int l = cnt[id][0]; l <= cnt[id][1]; l++)
                add(l, i);
        }
    }

    // Hungary
    int ans = 0;
    for(int i = 1; i < cur; i++){
        stamp++;
        if(dfs(i)) ans++;
    }
    
    if(ans != cur - 1) return void(cout << "No Solution!" << endl);
    for(int i = 1; i <= k; i++){
        cout << i << ":";
        for(int j = cnt[i][0]; j <= cnt[i][1]; j++)
            cout << ' ' << ok[j];
        cout << endl;
    }
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [P10936 导弹防御塔](https://www.luogu.com.cn/problem/P10936)(二分 + 二分图最大匹配)(省选/NOI−)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define arr2 array<int, 2>
const int N = 1e3 + 10, M = 2e5 + 10;
int n, m, h[N], e[M], ne[M], idx;
int vis[M], match[M], stamp;
double t1, t2, v;
arr2 tow[N], inv[N];
// invader: 入侵者, 侵略者
// tower: 塔

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

bool check(double mid){
    memset(match, 0, sizeof match);
    memset(vis, 0, sizeof vis);
    memset(h, -1, sizeof h);
    idx = stamp = 0;
    int maxk = min(m, (int)((mid + t2) / (t1 + t2)));
    // 单个导弹塔最多发射多少导弹
    for(int i = 1; i <= m; i++){ // 遍历入侵者
        for(int j = 1; j <= n; j++){ // 遍历塔
            double tmp = sqrt((inv[i][0] - tow[j][0]) * (inv[i][0] - tow[j][0])
                + (inv[i][1] - tow[j][1]) * (inv[i][1] - tow[j][1])) / v;
            // tmp = 导弹从发射到命中的时间 = distance / v
            for(int k = 1; k <= maxk; k++){
                if(tmp + (k - 1) * (t1 + t2) + t1 > mid) continue;
                add(i, m + (j - 1) * maxk + k);
                // (j - 1) * maxk + k即为第j个防御塔的第k个导弹编号
                // 加上 m 防止导弹编号与入侵者编号冲突
            }
        }
    }
    for(int i = 1; i <= m; i++){
        stamp++;
        if(!dfs(i)) return false;
    }
    return true;
}

void solve(){
    cin >> n >> m >> t1 >> t2 >> v;
    t1 /= 60;
    for(int i = 1; i <= m; i++) cin >> inv[i][0] >> inv[i][1];
    for(int i = 1; i <= n; i++) cin >> tow[i][0] >> tow[i][1];
    double l = 0, r = 200000, mid;
    int max_it = ceil(log2((r - l) * 1e5)) + 2;
    // iteration(反复): 记录第几次迭代
    for(int it = 0; it < max_it; it++){
        mid = (l + r) / 2;
        if(check(mid)) r = mid;
        else l = mid;
    }
    cout << fixed << setprecision(6) << l << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```

## [P2065 [TJOI2011] 卡片](https://www.luogu.com.cn/problem/P2065)(二分图最大匹配)(数学)
求gcd的时间复杂度是 $log$ ，暴力建图的时间复杂度是 $mnlogw \ , \ w \le 10^7$，考虑多测，最劣的建图时间复杂度为 $Tnmlogw(1 \le w \le 10^7) = 5e8$，加上其他的操作，在 $1s$ 之内容易 $TLE$，实际真的会 $TLE$。
所以考虑优化建图，从题目性质出发。**两个数最大公约数大于 1，就是说两个数至少有一个公共质因数**。考虑拆边，引入关键点表示两数的公共质因数。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define vi vector<int>
const int N = 5e2 + 10, M = 2.5e4 + 10;
int n, m, h[N << 1], e[M], ne[M], idx;
int vis[N << 1], match[N << 1], stamp;
int bl[N], re[N]; // 蓝色，红色

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

vi factor(int x){ // 分解质因数(去重)
    vi tmp;
    for(int i = 2; i * i <= x; i++){
        if(x % i == 0){
            tmp.push_back(i);
            while(x % i == 0) x /= i;
        }
    }
    if(x > 1) tmp.push_back(x);
    return tmp;
}

void solve(){
    memset(h, -1, sizeof h);
    memset(vis, 0, sizeof vis);
    memset(match, 0, sizeof match);
    idx = stamp = 0;
    cin >> m >> n;
    for(int i = 1; i <= m; i++) cin >> bl[i];
    for(int i = 1; i <= n; i++) cin >> re[i];

    unordered_map<int, vi> mp;
    // mp: 质因数，含有这个质因数的数字的下标
    for(int i = 1; i <= m; i++){
        vi prims = factor(bl[i]);
        for(int x : prims)
            mp[x].push_back(i);
    }
    for(int i = m + 1; i <= m + n; i++){
        vi prims = factor(re[i - m]);
        for(int x : prims)
            for(int y : mp[x])
                add(i, y);
    }
    int ans = 0;
    for(int i = m + 1; i <= m + n; i++){
        stamp++;
        if(dfs(i)) ans++;
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    cin >> T;
    while(T--) solve();
    return 0;
}
```
# 二分图最小点覆盖
## 柯尼希（König）定理
**König 定理：对任意二分图 G，其最大匹配数等于最小顶点覆盖数**
**换句话说，** 二分图中 “能选多少条互不相交的边” 与 “要选多少个顶点才能覆盖所有边” 这两个看似相对立的问题，答案完全相同。
## [P7368 [USACO05NOV] Asteroids G](https://www.luogu.com.cn/problem/P7368)(二分图最小点覆盖)
>二分图最小覆盖的模型特点是：每条边有 2 个端点，二者至少选择一个。我们不妨称之为 "2 要素"。
——李煜东《算法竞赛进阶指南》

我们来寻找一下本题的 "2 要素"：
每个小行星可以通过本行的武器或每列的武器被消除，二者至少选择一个。
我们将每个小行星的 x 坐标与 y 坐标看成一条边的两个端点。那么形成的这张图中的任意一条边都需要有至少一个端点有武器摆放。
换句话说，问题就是要求出一个最小的点集 S，使得图中任意一条边都有至少一个端点属于 S。这个问题被称为**二分图的最小点覆盖**。
故求消除所有小行星的最小代价就相当于求这张二分图的最小点覆盖数。
根据 König 定理，**二分图最小点覆盖包含的点数等于二分图最大匹配包含的边数**。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define vi vector<int>
const int N = 5e2 + 10, M = 2.5e4 + 10;
int n, k, h[N], e[M], ne[M], idx;
int vis[N << 1], match[N << 1], stamp;

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    memset(h, -1, sizeof h);
    cin >> n >> k;
    for(int i = 1; i <= k; i++){
        int x, y; cin >> x >> y;
        add(x, n + y);
    }
    int ans = 0;
    for(int i = 1; i <= n; i++){
        stamp++;
        if(dfs(i)) ans++;
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```

## [P6062 [USACO05JAN] Muddy Fields G](https://www.luogu.com.cn/problem/P6062)(二分图最小点覆盖)
**本题的 "2 要素"：** `*` 至少被横板和竖板其中一个覆盖，求二分图最小点覆盖
木板要么是横向的，要么是纵向的。这样我们就可以建立二分图，一个表示横向的，一个表示纵向的。
假设所有的木板都是横向的，我们记录下哪几个是同一块木板的(用数组记录，属于同一块木板的点，数字相同，否则数字不同)。
由于全部是横向的，那么可以采用贪心策略。即找出所有**连续**的横泥地，在同一个**连续**的横泥地里它们就可以用同一块木板覆盖。
竖着的木板和横着的木板思路一样。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define pii pair<int, int>
const int N = 60, M = 50 * 25 + 10, E = 2 * M;
// 考虑横板和竖板数量的最劣情况：每行每列间隔一个' '，出现一个'*'
// 因此横板和竖板最多各有 M = 50 * 25 块
// 粗略估计连边的最劣情况：50行 * 50列 = 2500（其实没有这么多）
int n, m, row[N][N], col[N][N];
// row[i][j]: 记录点{i, j}的横板编号
// col[i][j]: 记录点{i, j}的竖板编号

char a[N][N];
int h[M], e[E], ne[E], idx;
int vis[E], match[E], stamp;

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    memset(h, -1, sizeof h);
    cin >> n >> m;
    int sumx = 1, sumy = M + 1;
    // sumx 和 sumy 作为横板和竖板的起始下标
    //set<pii> st; // 防止建重边，减少建边开销
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++){
            cin >> a[i][j];
            if(a[i][j] == '*'){
                row[i][j] = (a[i][j - 1] == '*' ? row[i][j - 1] : sumx++);
                col[i][j] = (a[i - 1][j] == '*' ? col[i - 1][j] : sumy++);
                //if(st.count({row[i][j], col[i][j]})) continue;
                add(row[i][j], col[i][j]);
                //st.insert({row[i][j], col[i][j]});
            }
        }
    int ans = 0;
    for(int i = 1; i < sumx; i++){
        stamp++;
        if(dfs(i)) ans++;
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [P2825 [HEOI2016/TJOI2016] 游戏](https://www.luogu.com.cn/problem/P2825)(二分图最小点覆盖)(省选/NOI−)
**前置题目：**
1. [P10937 車的放置](https://www.luogu.com.cn/problem/P10937)(二分图最大匹配)
2. [P1129 [ZJOI2007] 矩阵游戏](https://www.luogu.com.cn/problem/P1129)(二分图最大匹配) 
3. [P6062 [USACO05JAN] Muddy Fields G](https://www.luogu.com.cn/problem/P6062)(二分图最小点覆盖) 
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 25 * 50 + 10, M = 2 * N;
int n, m, h[N], e[M], ne[M], idx;
int vis[M], match[M], stamp, row[60][60], col[60][60];
char g[60][60];
int sumx = 1, sumy = N + 1;

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    memset(h, -1, sizeof h);
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++){
            cin >> g[i][j];
            if(g[i][j] != '#'){
                row[i][j] = (g[i][j - 1] == '*' || g[i][j - 1] == 'x') ? row[i][j - 1] : sumx++;
                col[i][j] = (g[i - 1][j] == '*' || g[i - 1][j] == 'x') ? col[i - 1][j] : sumy++;
                if(g[i][j] == '*') add(row[i][j], col[i][j]);
            }
        }
    int ans = 0;
    for(int i = 1; i < sumx; i++){
        stamp++;
        if(dfs(i)) ans++;
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```

## [P3231 [HNOI2013] 消毒](https://www.luogu.com.cn/problem/P3231)(二分图最小点覆盖)(省选/NOI−)
1. **问题建模**
* 三维实验皿大小 $a\times b\times c$，在部分单位立方体上标记了“需消毒”。
* 对任意尺寸为 $x\times y\times z$ 的子长方体消毒，花费 $\min(x,y,z)$。

2. **降维到「整层清」+「二维覆盖」**
* 令三维的最小维度为 “高” $=$ `mn`，其余两个维度分别作为“行”“列”。
* **操作 1：** 整层清理一个层（高维上厚度 1、横跨整个行×列 面积），花费 1。
* **操作 2：** 对剩余未整层清的点，投影到行×列 平面，等价于在一个二分图上做「最小点覆盖」——选行或列覆盖所有点，每选一行或一列都花费 1，最小点覆盖数等于最大匹配数。 
3. **枚举哪几层整层清**
* 三维最小维度 `mn ≤ 17`，可枚举 $2^{mn}$ 个子集（用位掩码 `mask` 表示哪些层整层清）。
* 对于每个 `mask`：
	1. 花费 $\text{popcount}(mask)$ 单位试剂清这些层。
	
	2. 将剩余点在行×列平面上构建二分图，求最大匹配数 $m$，再花费 $m$ 单位试剂。
* 取各 `mask` 的最小总花费。
4. **链式前向星 + 匈牙利**
* 用链式前向星存图高效维护动态二分图：每条边需记录它属于哪一层（为了根据 `mask` 跳过已整层清的边）。
* 匈牙利算法中，DFS 遍历每个左节点的边，跳过 `mask` 标记为“已清理”的层对应的边。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define arr3 array<int, 3>
const int N = 5e3 + 10, M = 5e3 + 10, inf = 0x3f3f3f3f;
int a, b, c;
int h[N], e[M], ne[M], w[M], idx;
// w[i] = 第 i 条边对应的“层号” (1..mn)
int vis[N], match[N], del[20], stamp;
// del[layer] = 1 表示该层被一次性清理

void add(int a, int b, int c){
    w[idx] = c;
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i], layer = w[i];
        if(del[layer] || vis[v] == stamp) continue;
        // 如果该层在 mask 中被一次性清掉，或 v 在本次 dfs 已被访问，跳过
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    memset(h, -1, sizeof h);
    idx = stamp = 0;
    cin >> a >> b >> c;
    vector<arr3> pts;
    // points: pts
    // 记录所有“需消毒”点的坐标
    for(int i = 1; i <= a; i++)
        for(int j = 1; j <= b; j++)
            for(int k = 1; k <= c; k++){
                int x; cin >> x;
                if(x) pts.push_back({i, j, k});
            }
    int mn = min({a, b, c});
    // 确定最小维度 mn，把它当“高”（需要枚举的层数）
    int pos = (mn == a ? 1 : (mn == b ? 2 : 3));
    for(auto &[i, j, k] : pts){
        if(pos == 1) add(j, k, i);
        else if(pos == 2) add(i, k, j);
        else add(i, j, k);
    }
    int ans = inf;
    int lim = max({a, b, c});
    for(int mask = 0; mask < (1ll << mn); mask++){
        // 先清理整被掩码选中的层，花费 popcount(mask)
        int cur_cost = __builtin_popcount(mask);
        for(int layer = 1; layer <= mn; layer++)
            del[layer] = (mask >> (layer - 1)) & 1;
        fill(match + 1, match + lim + 1, 0);
        for(int u = 1; u <= lim; u++){
            stamp++;
            if(dfs(u)) cur_cost++;
        }
        ans = min(ans, cur_cost);
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    cin >> T;
    while(T--) solve();
    return 0;
}
```

## [UVA1194 Machine Schedule](https://www.luogu.com.cn/problem/UVA1194)(二分图最小点覆盖)(模板)
没有UVa账号的话，可以用 [Vjudge](https://vjudge.net/problem/UVA-1194) 提交
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 1e2 + 10, M = 1e3 + 10, inf = 0x3f3f3f3f;
int n, m, k, h[N], e[M], ne[M], idx;
int vis[N], match[N], stamp;

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
   while(cin >> n && n){
        cin >> m >> k;
        memset(h, -1, sizeof h);
        memset(vis, 0, sizeof vis);
        memset(match, 0, sizeof match);
        idx = stamp = 0;
        for(int i = 1; i <= k; i++){
            int a, b, c; cin >> a >> b >> c;
            add(b, c);
        }
        int ans = 0;
        for(int i = 1; i <= n; i++){
            stamp++;
            ans += dfs(i);
        }
        cout << ans << endl;
   }
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```

# 有向无环图的最小路径点覆盖
给定一张**有向无环图**，用尽量少的不相交的简单路径覆盖所有点（也就是每个点恰好被覆盖一次），这样的路径集合被称为**最小路径点覆盖**。
* **路径覆盖（path cover）**：在有向图中，选取若干条**顶点无重叠**的路径，使得图中每个顶点都恰好属于一条选中的路径。
* **最小路径覆盖（minimum path cover）**：在所有可能的路径覆盖中，使选中的路径条数最少。

对于给定的 DAG $G=(V,E)$，求最小路径覆盖的大小，以及一组实际的路径。

**DAG 最小路径覆盖有如下经典结论：** 
$\operatorname{minimumPathCover}(G) = |V| - \operatorname{maximumMatching}(B)$
**也就是：** 有向无环图的最小路径点覆盖包含的路径条数，等于 n− 拆点二分图的最大匹配边数。
其中，$B$ 是从 DAG 构造出的一个二分图，最大匹配数通过匈牙利或 Hopcroft–Karp 算法得到。

**从 DAG 到二分图的转化：**
* 将原图的每个顶点 $v\in V$ 在二分图中拆成左右两份：左侧集合 $L$ 中的顶点记为 $v_{out}$，右侧集合 $R$ 中的顶点记为 $v_{in}$。
* 对于原图中每条有向边 $u\to v\in E$，在二分图中添加一条从 $u_{out}$ 向 $v_{in}$ 的边。

此二分图共 $|V|$ 个左节点、$|V|$ 个右节点，至多 $|E|$ 条边。
## [UVA1201 Taxi Cab Scheme](https://www.luogu.com.cn/problem/solution/UVA1201)(DAG最小路径点覆盖)(省选/NOI−)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 5e2 + 10, M = 25e4 + 10;
// 其实 M 远远没有这么多
int n, tmp1, tmp2, x, y, nx, ny;
char ch;
int h[N], e[M], ne[M], idx;
int vis[N], match[N], stamp;

int calc(int x, int y, int nx, int ny){
    return abs(x - nx) + abs(y - ny);
}

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    memset(h, -1, sizeof h);
    memset(vis, 0, sizeof vis);
    memset(match, 0, sizeof match);
    idx = stamp = 0;
    cin >> n;
    vector<array<int, 5>> ver(n + 1);
    // 小tirck: 08:10 等时间，可以用int char int读取
    // 读取之后分别为 "8"、":"、"10"
    for(int i = 1; i <= n; i++){
        cin >> tmp1 >> ch >> tmp2 >> ver[i][1] >> ver[i][2] >> ver[i][3] >> ver[i][4];
        ver[i][0] = tmp1 * 60 + tmp2;
    }
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++){
            int t1 = calc(ver[i][1], ver[i][2], ver[i][3], ver[i][4]);
            int t2 = calc(ver[i][3], ver[i][4], ver[j][1], ver[j][2]);
            if(ver[i][0] + t1 + t2 < ver[j][0])
                add(i, j);
        }
    int ans = 0;
    for(int i = 1; i <= n; i++){
        stamp++;
        ans += dfs(i);
    }
    cout << n - ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    cin >> T;
    while(T--) solve();
    return 0;
}
```
## [P2172 [国家集训队] 部落战争](https://www.luogu.com.cn/problem/P2172)(DAG最小路径点覆盖)(省选/NOI−)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define f(i, j) ((i - 1) * m + (j))
const int N = 2500 + 10, M = 1e4 + 10;
int n, m, d1, d2;
int h[N], e[M], ne[M], idx;
int vis[N], match[N], stamp;
char g[N];

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] ==  stamp || g[v] == 'x') continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    memset(h, -1, sizeof h);
    cin >> n >> m >> d1 >> d2;
    for(int i = 1; i <= n * m; i++) cin >> g[i];
    int cnt = 0; // 记录'.'个数
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            if(g[f(i, j)] == 'x') continue;
            cnt++;
            for(int k = -1; k <= 1; k += 2){
                int nx = i + d1, ny = j + k * d2;
                // 只能向下走，所以 nx 必定是加法
                if(nx < 1 || nx > n || ny < 1 || ny > m || g[f(nx, ny)] == 'x')
                    continue;
                add(f(i, j), f(nx, ny));
            }
            if(d1 == d2) continue;
            // 如果 d1 == d2 四种跳法两两重叠
            for(int k = -1; k <= 1; k += 2){
                int nx = i + d2, ny = j + k * d1;
                if(nx < 1 || nx > n || ny < 1 || ny > m || g[f(nx, ny)] == 'x')
                    continue;
                add(f(i, j), f(nx, ny));
            }
        }
    }
    int ans = 0; // 二分图最大匹配
    for(int i = 1; i <= n * m; i++){
        if(g[i] == 'x') continue;
        stamp++;
        ans += dfs(i);
    }
    cout << cnt - ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [P2764 最小路径覆盖问题](https://www.luogu.com.cn/problem/P2764)(DAG最小路径点覆盖)(省选/NOI−)
用 $match[i]$ 判断，如果 $match[i] = 0$，说明没有前驱，说明自己是第一个，要单开一行
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define vi vector<int>
const int N = 150 + 10, M = 6e3 + 10;
int n, m, h[N], e[M], ne[M], idx;
int vis[N], match[N], stamp, ok[N];

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] ==  stamp) continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            ok[u] = v;
            return true;
        }
    }
    return false;
}

void solve(){
    memset(h, -1, sizeof h);
    cin >> n >> m;
    for(int i = 1; i <= m; i++){
        int x, y; cin >> x >> y;
        add(x, y);
    }
    int ans = 0;
    for(int i = 1; i <= n; i++){
        stamp++;
        ans += dfs(i);
    }
    for(int i = 1; i <= n; i++){
        if(!match[i]){
            // 如果没有前驱，说明自己是第一个，要单开一行
            cout << i;
            int u = i;
            while(ok[u]){
                cout << ' ' << ok[u];
                u = ok[u];
            }
            cout << endl;
        }
    }
    cout << n - ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```


## 持续更新中