---
title: 二分图（从入门到入土）
date: 2025-05-19 18:59:07
tags:
    - 二分图
categories:
    - 算法笔记
---

# 二分图判定
## 什么是二分图？
**二分图：** 节点由两个集合组成，且两个集合内部没有边的图。换言之，存在一种方案，将节点划分成满足以上性质的两个集合。
—— OI-wiki
![](/images/二分图示例.png)
如图，在一个图中，如果能把点分为**两个顶点集**，使**每个集合中，没有两个点有连边**。
也就是说，**边只会连接两个点集**。
## 如何判定二分图？
**存在定理：一张无向图是二分图,当且仅当图中不存在奇环(长度为奇数的环)**
**根据该定理**，可以以染色法进行二分图的判定。主体思想为：尝试用黑白两种颜色标记图中的结点，当一个结点被标记后，它的所有相邻结点应该被标记与它相反的颜色。若标记过程中产生冲突，则说明图中存在奇环。二分图染色一般基于DFS实现，时间复杂度为$\mathcal O(n+m)$
**伪代码如下：**
```cpp
void dfs(int x,int color){
	赋值v[x] <-- color
	对于与x相连的每条无向边(x,y)
	if v[y]=0 then
		dfs(y,3-color)
	else if v[y]=color then 
		判定无向图不是二分图,算法结束
	}

在主函数中
	for i <-- 1 to n
		if(v[i]=0)then dfs(i,1)
	判定无向图是二分图
```
## [P1330 封锁阳光大学](https://www.luogu.com.cn/problem/P1330)(二分图判定)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 1e4 + 10, M = 2e5 + 10;
int n, m, h[N], e[M], ne[M], idx, col[N];
array<int, 2> sum;

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

void dfs(int u, int vis){
    col[u] = vis;
    sum[vis & 1]++;
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(col[v]){
            if(col[v] == col[u]){
                cout << "Impossible" << endl;
                exit(0);
            }
        }else dfs(v, 3 - vis);
    }
}

void solve(){
    cin >> n >> m;
    fill(h + 1, h + n + 1, -1);
    for(int i = 1; i <= m; i++){
        int a, b; cin >> a >> b;
        add(a, b);
        add(b, a);
    }
    int ans = 0;
    for(int i = 1; i <= n; i++){
        sum = {0, 0};
        if(!col[i]) dfs(i, 1);
        ans += min(sum[0], sum[1]);
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```

## [P1525 [NOIP 2010 提高组] 关押罪犯](https://www.luogu.com.cn/problem/P1525)(二分答案+ 二分图判定)(可用并查集)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 2e4 + 10, M = 2e5 + 10;
int n, m, a[M], b[M], c[M], id[M];
int h[N], e[M], ne[M], idx;
int col[N];
int ok;

void add(int u, int v){
    e[idx] = v;
    ne[idx] = h[u];
    h[u] = idx++;
}

void dfs(int u, int vis){
    col[u] = vis;
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(col[v]){
            if(col[u] == col[v])
                return void(ok = 0);
        }else dfs(v, 3 - vis);
    }
}

bool check(int pos){
    idx = 0;
    fill(h + 1, h + n + 1, -1);
    for(int i = pos; i <= m; i++){
        int j = id[i];
        add(a[j], b[j]);
        add(b[j], a[j]);
    }
    ok = 1;
    fill(col + 1, col + n + 1, 0);
    for(int i = 1; i <= n && ok; i++)
        if(!col[i]) dfs(i, 1);
    return ok;
}

void solve(){
    cin >> n >> m;
    for(int i = 1; i <= m; i++){
        cin >> a[i] >> b[i] >> c[i];
        id[i] = i;
    }
    sort(id + 1, id + m + 1, [&](int i, int j){
        return c[i] < c[j];
    });
    int l = 1, r = m + 1;
    while(l < r){
        int mid = (l + r) >> 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    cout << c[id[l - 1]] << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [CF19E. Fairy](https://codeforces.com/contest/19/problem/E)(树上差分 + 二分图判定)(2900)
**解决的问题： 在一个无向图中，找出所有「删除后能使图变成二分图（无奇环）」的边。**
**时间复杂度：**
- 建图 + DFS：$\mathcal O(n + m)$
- 最后枚举所有边判断：$\mathcal O(m)$
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define vi vector<int>
const int N = 2e5 + 10, M = 4e5 + 10;
int n, m, h[N], e[M], ne[M], eid[M], idx;
// eid[idx]: 当前有向边对应的「原始边编号」（1…m）

void add(int a, int b, int id){
    eid[idx] = id;
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

int dep[N], p[N], fl[N], c1[N], c2[N], cnt_odd = 0;
// —— DFS 及差分数组准备 ——
// dep[u]: 深度（根节点深度为 1）
// p[u]: 进入 u 时所用的「原始边编号」
// fl[id]: 标记原始编号为 id 的边是否为树边
// c1[id], c2[id]: 差分数组，分别统计「参与奇环」和「参与偶环」的次数
// cnt_odd: 全局奇环总数


/*
DFS 遍历，构造生成树并统计基环奇偶性
u   当前节点
fa  父节点
pre 从 fa → u 使用的有向边下标（根节点传 -1）
 */
void dfs(int u, int fa, int pre){
    dep[u] = dep[fa] + 1;
    if(pre != -1) p[u] = eid[pre]; // 记录进 u 时的「原始边编号」
    for(int i = h[u]; ~i; i = ne[i]){ // 遍历 u 的所有出边
        int v = e[i];
        if(i == (pre ^ 1)) continue; // 跳过回到父节点时的那条反向边
        if(!dep[v]){ // 树边  
            dfs(v, u, i);
            fl[eid[i]] = 1; // 标记这条原始边为树边
            // 把子树传上来的差分信息累加到「进 u 的那条树边」上
            if(pre != -1){
                c1[p[u]] += c1[eid[i]];
                c2[p[u]] += c2[eid[i]];
            }
        }else if(dep[u] > dep[v]){
            // —— 回边 —— 构成一个基环
            int len = dep[u] - dep[v] + 1;
            if(len & 1){ // 奇环
                c1[eid[i]]++; // 回边自身 +1
                if(pre != -1) c1[p[u]]++; // 从 u 往上差分
                if(p[v]) c1[p[v]]--; // 到 v 停止
                cnt_odd++;
            }else{ // 偶环
                c2[eid[i]]++;
                if(pre != -1) c2[p[u]]++;
                if(p[v]) c2[p[v]]--;
            }
        }
    }
}

void solve(){
    cin >> n >> m;
    fill(h + 1, h + n + 1, -1);
    for(int i = 1; i <= m; i++){
        int u, v; cin >> u >> v;
        add(u, v, i); add(v, u, i);
    }
    for(int i = 1; i <= n; i++){
        if(!dep[i]) dfs(i, 0, -1);
    }
    vi ans;
    if(cnt_odd == 0){
        // 原图已是二分图：任意一条边都可删除
        for(int i = 1; i <= m; i++)
            ans.emplace_back(i);
    }else{
        // 存在奇环，按树边/回边条件筛选
        for(int i = 1; i <= m; i++){
            if(fl[i]){
                // 树边：必须切断所有奇环且不能破坏任何偶环
                if(c1[i] == cnt_odd && c2[i] == 0)
                    ans.emplace_back(i);
            }else{
                // 回边：仅当全局只有这 1 条奇环，且它就是这条边
                if(cnt_odd == 1 && c1[i] == 1)
                    ans.emplace_back(i);
            }
        }
    }
    cout << ans.size() << endl;
    for(auto x : ans) cout << x << " \n"[x == ans.back()];
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```

# 二分图最大匹配
## 二分图最大匹配是什么？
**匹配：** 在图论中，一个「匹配」是一个边的集合，其中任意两条边都没有公共顶点。
**二分图最大匹配**，顾名思义就是一个点**最多只能有与其有关系的一条边**被选中，问最多能选择多少条边
换作夫妻匹配问题，就是问在**一夫一妻制**下最多能找到多少对~~海王~~夫妻
著名的解决二分图最大匹配问题的算法为**匈牙利算法**，也可以借助**最大流/最小割**模型解决这类问题
## 匈牙利（Hungary）算法
**求二分图最大匹配的一般是用匈牙利算法** ~~，因为好写~~。
### 引入
**匈牙利算法**是基于**深度优先搜索**一遍一遍搜索**增广路**的存在性来增加匹配对数的
首先，要先知道一个叫**增广路**的东西。

> 若 P 是图 G 中一条连通两个未匹配顶点的路径，并且属于 M 的边和不属于 M 的边(即已匹配和待匹配的边)在 P 上交替出现，则称 P 为相对于 M 的一条增广路径（举例来说，有 A、B 集合，增广路由 A 中一个点通向B中一个点，再由 B 中这个点通向 A 中一个点……交替进行）。 ——百度百科

假设当前存在一条边 (u,v)，我们希望这条边加入匹配。
首先如果选的这条边满足 (u,v) 都尚未匹配，那我们可以直接把这条边加入答案，这样会使匹配数加一。
但如果两个点存在一个点有匹配另一个点，不妨假设点 u 除了这条边还存在另一个匹配 (u,v′)。这意味着点 u 被选了两次。于是我们希望点 v′ 能不选。
于是如果点 v′ 所连出的边除去 (u,v′) 外依然存在一条边 (v′,v′′) 没被选，那就可以扔掉 (u,v′) 加入 (v′,v′′)。如果 v′′ 尚未有匹配点，那么就直接结束该过程。否则再对 v′′ 做类似 u 的判断。
这意味着我们最后找出来的路径一定是一条不是匹配的边，一条是匹配的边交替出现。以最后一点尚未匹配作为结束条件。
根据上面描述的过程，最后我们只需要反转这些边的状态，即匹配的变成非匹配边，非匹配边变成匹配边。
可以发现这就是找增广路的过程，这说明我们只要找一条增广路，然后反转上面的点即可。这意味着若存在增广路，那么答案会增加一，否则答案不会变。
那我们一直找增广路，当不存在增广路时，得到的结果就是最大匹配了。

**生动形象的描述：**
我们将问题看作相亲现场，每个 $U$ 集合的人排队寻找 $V$ 集合里的对象
假设是男生排队找女生，基于这个"时间"顺序，假设前面的男生已经匹配了一些
下一个男生 $a$ 进来匹配，算法便会遍历一遍他认识的女生（与他有关系的 $V$ 集内的点）
如果发现当前遍历到的女生还没有被其他男生匹配，那非常好，就直接把这个女生匹配给男生 $a$
如果发现已经被其他男生 $b$ 给~~绿~~匹配了，那算法会尝试去和那个男生 $b$ 沟通，询问能否让他换一个（？）
算法便会来到那个男生 $b$ 那里，重新遍历一遍他认识的女生，看看能否找到其他能够匹配的女生（寻找增广路/套娃）
如果可以，那么男生 $b$ 便会与新找到的女生匹配，顺利成章的，原来与男生 $b$ 匹配的女生就可以和男生 $a$ 匹配啦
如果不行，那么男生 $a$ 就没这个机会了，尝试下一个吧（继续遍历），实在不行（遍历完了）单着挺好的
就以这样的方法一直搜索，直到所有男生（$U$ 集）该匹配的都匹配完了，就能得到最大匹配数了
### 代码实现
下面使用 $vector \ G$ 来储存每个男生认识的女生
使用 $int \ match$ 来储存每个女生当前匹配的男生的编号（没匹配则为 $0$）
如上面所说，我们需要遍历每个 $U$ 集的男生去尝试匹配
对于每个男生 $p$ ，要遍历一遍他认识的女生
```cpp
for(int i : G[p])
```
此时女生的编号便以 $i$ 来表示
如果当前的女生没被匹配到，自然可以直接让她与当前的男生 $p$ 进行匹配
但如果已经被匹配过，则尝试让匹配她的那个男生去再找找看其他女生（开始套娃），如果返回 $true$ 也可以正常匹配
```cpp
for(int i : G[p]){
    if(!match[i] || hungary(match[i])){
        match[i] = p;
        return true;
    }
}
```
那么对于这个套娃应该如何处理呢
每次搜索时都假设自己没匹配到，那么上面的代码可以满足搜索的功能
但是可以发现一个问题，从第二层寻找增广的搜索开始，$match$ 数组的值是没有变的（也就是说在寻找到新的女生之前，第一层遍历到的那个女生的 $match$ 依旧是第二层的这个男生）
第二层这个男生一定还会再找到这个女生，于是便会开始无限套娃死循环 $Runtime \ Error$
所以我们需要新开一个数组 $vis$ 来储存当前这一遍搜索是否已经让某个男生找过增广路了（找过了就不用再找了反正也找不到，正在找的话就直接退出防止套娃）
至此这个搜索函数算是完整了
```cpp
bool hungary(int p){
    if(vis[p]) //防止套娃
        return false;
    vis[p] = true; //访问标记
    for(int i : G[p]){
        if(!match[i] || hungary(match[i])){
            match[i] = p;
            return true; //海王在世
        }
    }
    return false; //单身贵族
}
```
但是先这样使用 $bool \ vis$ 的话有个弊端，也就是每次搜索某个男生时都要清空一次，时间耗费总和挺大的
所以我们可以在传值的时候再加个趟数 $op$ ，表示这是第几趟匹配了（或者表示这一趟主要是为了让哪个男生找女生），这样使用 $int \ vis$ 便可以做到不清空解决问题
```cpp
bool hungary(int p,int op){ //新增传值
    if(vis[p] == op) //依据趟数防止套娃
        return false;
    vis[p] = op; //标记这一趟是否访问过
    for(int i : G[p]){
        if(!match[i] || hungary(match[i], op)){
            match[i] = p;
            return true;
        }
    }
    return false;
}
```

## [P3386 【模板】二分图最大匹配 ](https://www.luogu.com.cn/problem/P3386)(二分图最大匹配)
**注意每次 DFS 之前，清空 vis**
如果不在每次新的 $u$ 发起 DFS 之前清空 $vis$，那么上一次为另一个左点匹配过程中标记过的右点就会被“永远跳过”
**时间复杂度： 每次 DFS 最坏会遍历所有边，次数为 $n$，因此  $\mathcal O(n⋅e)$。**
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define vi vector<int>
const int N = 5e2 + 10, M = 5e4 + 10;
int n, m, k, ans;
int h[N], e[M], ne[M], idx;
int vis[N], match[N];

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v]) continue;
        vis[v] = 1;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> n >> m >> k;
    fill(h + 1, h + n + 1, -1);
    for(int i = 1; i <= k; i++){
        int a, b; cin >> a >> b;
        add(a, b);
    }
    for(int i = 1; i <= n; i++){
        memset(vis, 0, sizeof vis);
        if(dfs(i)) ans++;
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```

## 持续更新中