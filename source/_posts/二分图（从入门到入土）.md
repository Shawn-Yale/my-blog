---
title: 二分图（从入门到入土）
date: 2025-05-19 18:59:07
tags:
    - 二分图
categories:
    - 算法笔记
---

# 二分图判定
## 什么是二分图？
**二分图：** 节点由两个集合组成，且两个集合内部没有边的图。换言之，存在一种方案，将节点划分成满足以上性质的两个集合。
—— OI-wiki
![](/images/二分图示例.png)
如图，在一个图中，如果能把点分为**两个顶点集**，使**每个集合中，没有两个点有连边**。
也就是说，**边只会连接两个点集**。
## 如何判定二分图？
**存在定理：一张无向图是二分图,当且仅当图中不存在奇环(长度为奇数的环)**
**根据该定理**，可以以染色法进行二分图的判定。主体思想为：尝试用黑白两种颜色标记图中的结点，当一个结点被标记后，它的所有相邻结点应该被标记与它相反的颜色。若标记过程中产生冲突，则说明图中存在奇环。二分图染色一般基于DFS实现，时间复杂度为$\mathcal O(n+m)$
**伪代码如下：**
```cpp
void dfs(int x,int color){
	赋值v[x] <-- color
	对于与x相连的每条无向边(x,y)
	if v[y]=0 then
		dfs(y,3-color)
	else if v[y]=color then 
		判定无向图不是二分图,算法结束
	}

在主函数中
	for i <-- 1 to n
		if(v[i]=0)then dfs(i,1)
	判定无向图是二分图
```
## [P1330 封锁阳光大学](https://www.luogu.com.cn/problem/P1330)(二分图判定)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 1e4 + 10, M = 2e5 + 10;
int n, m, h[N], e[M], ne[M], idx, col[N];
array<int, 2> sum;

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

void dfs(int u, int vis){
    col[u] = vis;
    sum[vis & 1]++;
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(col[v]){
            if(col[v] == col[u]){
                cout << "Impossible" << endl;
                exit(0);
            }
        }else dfs(v, 3 - vis);
    }
}

void solve(){
    cin >> n >> m;
    fill(h + 1, h + n + 1, -1);
    for(int i = 1; i <= m; i++){
        int a, b; cin >> a >> b;
        add(a, b);
        add(b, a);
    }
    int ans = 0;
    for(int i = 1; i <= n; i++){
        sum = {0, 0};
        if(!col[i]) dfs(i, 1);
        ans += min(sum[0], sum[1]);
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```

## [P1525 [NOIP 2010 提高组] 关押罪犯](https://www.luogu.com.cn/problem/P1525)(二分答案+ 二分图判定)(可用并查集)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 2e4 + 10, M = 2e5 + 10;
int n, m, a[M], b[M], c[M], id[M];
int h[N], e[M], ne[M], idx;
int col[N];
int ok;

void add(int u, int v){
    e[idx] = v;
    ne[idx] = h[u];
    h[u] = idx++;
}

void dfs(int u, int vis){
    col[u] = vis;
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(col[v]){
            if(col[u] == col[v])
                return void(ok = 0);
        }else dfs(v, 3 - vis);
    }
}

bool check(int pos){
    idx = 0;
    fill(h + 1, h + n + 1, -1);
    for(int i = pos; i <= m; i++){
        int j = id[i];
        add(a[j], b[j]);
        add(b[j], a[j]);
    }
    ok = 1;
    fill(col + 1, col + n + 1, 0);
    for(int i = 1; i <= n && ok; i++)
        if(!col[i]) dfs(i, 1);
    return ok;
}

void solve(){
    cin >> n >> m;
    for(int i = 1; i <= m; i++){
        cin >> a[i] >> b[i] >> c[i];
        id[i] = i;
    }
    sort(id + 1, id + m + 1, [&](int i, int j){
        return c[i] < c[j];
    });
    int l = 1, r = m + 1;
    while(l < r){
        int mid = (l + r) >> 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    cout << c[id[l - 1]] << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [CF19E. Fairy](https://codeforces.com/contest/19/problem/E)(树上差分 + 二分图判定)(2900)
**解决的问题： 在一个无向图中，找出所有「删除后能使图变成二分图（无奇环）」的边。**
**时间复杂度：**
- 建图 + DFS：$\mathcal O(n + m)$
- 最后枚举所有边判断：$\mathcal O(m)$
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define vi vector<int>
const int N = 2e5 + 10, M = 4e5 + 10;
int n, m, h[N], e[M], ne[M], eid[M], idx;
// eid[idx]: 当前有向边对应的「原始边编号」（1…m）

void add(int a, int b, int id){
    eid[idx] = id;
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

int dep[N], p[N], fl[N], c1[N], c2[N], cnt_odd = 0;
// —— DFS 及差分数组准备 ——
// dep[u]: 深度（根节点深度为 1）
// p[u]: 进入 u 时所用的「原始边编号」
// fl[id]: 标记原始编号为 id 的边是否为树边
// c1[id], c2[id]: 差分数组，分别统计「参与奇环」和「参与偶环」的次数
// cnt_odd: 全局奇环总数


/*
DFS 遍历，构造生成树并统计基环奇偶性
u   当前节点
fa  父节点
pre 从 fa → u 使用的有向边下标（根节点传 -1）
 */
void dfs(int u, int fa, int pre){
    dep[u] = dep[fa] + 1;
    if(pre != -1) p[u] = eid[pre]; // 记录进 u 时的「原始边编号」
    for(int i = h[u]; ~i; i = ne[i]){ // 遍历 u 的所有出边
        int v = e[i];
        if(i == (pre ^ 1)) continue; // 跳过回到父节点时的那条反向边
        if(!dep[v]){ // 树边  
            dfs(v, u, i);
            fl[eid[i]] = 1; // 标记这条原始边为树边
            // 把子树传上来的差分信息累加到「进 u 的那条树边」上
            if(pre != -1){
                c1[p[u]] += c1[eid[i]];
                c2[p[u]] += c2[eid[i]];
            }
        }else if(dep[u] > dep[v]){
            // —— 回边 —— 构成一个基环
            int len = dep[u] - dep[v] + 1;
            if(len & 1){ // 奇环
                c1[eid[i]]++; // 回边自身 +1
                if(pre != -1) c1[p[u]]++; // 从 u 往上差分
                if(p[v]) c1[p[v]]--; // 到 v 停止
                cnt_odd++;
            }else{ // 偶环
                c2[eid[i]]++;
                if(pre != -1) c2[p[u]]++;
                if(p[v]) c2[p[v]]--;
            }
        }
    }
}

void solve(){
    cin >> n >> m;
    fill(h + 1, h + n + 1, -1);
    for(int i = 1; i <= m; i++){
        int u, v; cin >> u >> v;
        add(u, v, i); add(v, u, i);
    }
    for(int i = 1; i <= n; i++){
        if(!dep[i]) dfs(i, 0, -1);
    }
    vi ans;
    if(cnt_odd == 0){
        // 原图已是二分图：任意一条边都可删除
        for(int i = 1; i <= m; i++)
            ans.emplace_back(i);
    }else{
        // 存在奇环，按树边/回边条件筛选
        for(int i = 1; i <= m; i++){
            if(fl[i]){
                // 树边：必须切断所有奇环且不能破坏任何偶环
                if(c1[i] == cnt_odd && c2[i] == 0)
                    ans.emplace_back(i);
            }else{
                // 回边：仅当全局只有这 1 条奇环，且它就是这条边
                if(cnt_odd == 1 && c1[i] == 1)
                    ans.emplace_back(i);
            }
        }
    }
    cout << ans.size() << endl;
    for(auto x : ans) cout << x << " \n"[x == ans.back()];
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```

# 二分图最大匹配
## 二分图最大匹配是什么？
**匹配：** 在图论中，一个「匹配」是一个边的集合，其中任意两条边都没有公共顶点。
**二分图最大匹配**，顾名思义就是一个点**最多只能有与其有关系的一条边**被选中，问最多能选择多少条边
换作夫妻匹配问题，就是问在**一夫一妻制**下最多能找到多少对~~海王~~夫妻
著名的解决二分图最大匹配问题的算法为**匈牙利算法**，也可以借助**最大流/最小割**模型解决这类问题
## 匈牙利（Hungary）算法
**求二分图最大匹配的一般是用匈牙利算法** ~~，因为好写~~。
### 引入
**匈牙利算法**是基于**深度优先搜索**一遍一遍搜索**增广路**的存在性来增加匹配对数的
首先，要先知道一个叫**增广路**的东西。

> 若 P 是图 G 中一条连通两个未匹配顶点的路径，并且属于 M 的边和不属于 M 的边(即已匹配和待匹配的边)在 P 上交替出现，则称 P 为相对于 M 的一条增广路径（举例来说，有 A、B 集合，增广路由 A 中一个点通向B中一个点，再由 B 中这个点通向 A 中一个点……交替进行）。 ——百度百科

假设当前存在一条边 (u,v)，我们希望这条边加入匹配。
首先如果选的这条边满足 (u,v) 都尚未匹配，那我们可以直接把这条边加入答案，这样会使匹配数加一。
但如果两个点存在一个点有匹配另一个点，不妨假设点 u 除了这条边还存在另一个匹配 (u,v′)。这意味着点 u 被选了两次。于是我们希望点 v′ 能不选。
于是如果点 v′ 所连出的边除去 (u,v′) 外依然存在一条边 (v′,v′′) 没被选，那就可以扔掉 (u,v′) 加入 (v′,v′′)。如果 v′′ 尚未有匹配点，那么就直接结束该过程。否则再对 v′′ 做类似 u 的判断。
这意味着我们最后找出来的路径一定是一条不是匹配的边，一条是匹配的边交替出现。以最后一点尚未匹配作为结束条件。
根据上面描述的过程，最后我们只需要反转这些边的状态，即匹配的变成非匹配边，非匹配边变成匹配边。
可以发现这就是找增广路的过程，这说明我们只要找一条增广路，然后反转上面的点即可。这意味着若存在增广路，那么答案会增加一，否则答案不会变。
那我们一直找增广路，当不存在增广路时，得到的结果就是最大匹配了。

**生动形象的描述：**
我们将问题看作相亲现场，每个 $U$ 集合的人排队寻找 $V$ 集合里的对象
假设是男生排队找女生，基于这个"时间"顺序，假设前面的男生已经匹配了一些
下一个男生 $a$ 进来匹配，算法便会遍历一遍他认识的女生（与他有关系的 $V$ 集内的点）
如果发现当前遍历到的女生还没有被其他男生匹配，那非常好，就直接把这个女生匹配给男生 $a$
如果发现已经被其他男生 $b$ 给~~绿~~匹配了，那算法会尝试去和那个男生 $b$ 沟通，询问能否让他换一个（？）
算法便会来到那个男生 $b$ 那里，重新遍历一遍他认识的女生，看看能否找到其他能够匹配的女生（寻找增广路/套娃）
如果可以，那么男生 $b$ 便会与新找到的女生匹配，顺利成章的，原来与男生 $b$ 匹配的女生就可以和男生 $a$ 匹配啦
如果不行，那么男生 $a$ 就没这个机会了，尝试下一个吧（继续遍历），实在不行（遍历完了）单着挺好的
就以这样的方法一直搜索，直到所有男生（$U$ 集）该匹配的都匹配完了，就能得到最大匹配数了
### 代码实现
下面使用 $vector \ G$ 来储存每个男生认识的女生
使用 $int \ match$ 来储存每个女生当前匹配的男生的编号（没匹配则为 $0$）
如上面所说，我们需要遍历每个 $U$ 集的男生去尝试匹配
对于每个男生 $p$ ，要遍历一遍他认识的女生
```cpp
for(int i : G[p])
```
此时女生的编号便以 $i$ 来表示
如果当前的女生没被匹配到，自然可以直接让她与当前的男生 $p$ 进行匹配
但如果已经被匹配过，则尝试让匹配她的那个男生去再找找看其他女生（开始套娃），如果返回 $true$ 也可以正常匹配
```cpp
for(int i : G[p]){
    if(!match[i] || hungary(match[i])){
        match[i] = p;
        return true;
    }
}
```
那么对于这个套娃应该如何处理呢
每次搜索时都假设自己没匹配到，那么上面的代码可以满足搜索的功能
但是可以发现一个问题，从第二层寻找增广的搜索开始，$match$ 数组的值是没有变的（也就是说在寻找到新的女生之前，第一层遍历到的那个女生的 $match$ 依旧是第二层的这个男生）
第二层这个男生一定还会再找到这个女生，于是便会开始无限套娃死循环 $Runtime \ Error$
所以我们需要新开一个数组 $vis$ 来储存当前这一遍搜索是否已经让某个男生找过增广路了（找过了就不用再找了反正也找不到，正在找的话就直接退出防止套娃）
至此这个搜索函数算是完整了
```cpp
bool hungary(int p){
    if(vis[p]) //防止套娃
        return false;
    vis[p] = true; //访问标记
    for(int i : G[p]){
        if(!match[i] || hungary(match[i])){
            match[i] = p;
            return true; //海王在世
        }
    }
    return false; //单身贵族
}
```
但是先这样使用 $bool \ vis$ 的话有个弊端，也就是每次搜索某个男生时都要清空一次，时间耗费总和挺大的
所以我们可以在传值的时候再加个趟数 $op$ ，表示这是第几趟匹配了（或者表示这一趟主要是为了让哪个男生找女生），这样使用 $int \ vis$ 便可以做到不清空解决问题
```cpp
bool hungary(int p,int op){ //新增传值
    if(vis[p] == op) //依据趟数防止套娃
        return false;
    vis[p] = op; //标记这一趟是否访问过
    for(int i : G[p]){
        if(!match[i] || hungary(match[i], op)){
            match[i] = p;
            return true;
        }
    }
    return false;
}
```

## [P3386 【模板】二分图最大匹配 ](https://www.luogu.com.cn/problem/P3386)(二分图最大匹配)
**注意每次 DFS 之前，清空 vis**
如果不在每次新的 $u$ 发起 DFS 之前清空 $vis$，那么上一次为另一个左点匹配过程中标记过的右点就会被“永远跳过”
**时间复杂度： 每次 DFS 最坏会遍历所有边，次数为 $n$，因此  $\mathcal O(n⋅e)$。**
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 5e2 + 10, M = 5e4 + 10;
int n, m, k, ans;
int h[N], e[M], ne[M], idx;
int vis[N], match[N];

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v]) continue;
        vis[v] = 1;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> n >> m >> k;
    fill(h + 1, h + n + 1, -1);
    for(int i = 1; i <= k; i++){
        int a, b; cin >> a >> b;
        add(a, b);
    }
    for(int i = 1; i <= n; i++){
        memset(vis, 0, sizeof vis);
        // 注意清空 vis
        if(dfs(i)) ans++;
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [AcWing372. 棋盘覆盖](https://www.acwing.com/file_system/file/content/whole/index/content/3923/)(二分图最大匹配)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define pii pair<int, int>
const int N = 100 + 10;
int n, m, a[N][N], vis[N][N];
// a[i][j] = 1 表示 (i,j) 禁止放置
pii match[N][N];
int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};

bool dfs(int x, int y){
    for(int i = 0; i < 4; i++){
        int nx = x + dx[i], ny = y + dy[i];
        if(nx < 1 || nx > n || ny < 1 || ny > n) continue;
        if(a[nx][ny] || vis[nx][ny]) continue;
        vis[nx][ny] = 1;
        if(match[nx][ny] == make_pair(-1ll, -1ll) ||
            dfs(match[nx][ny].first, match[nx][ny].second)){
                match[nx][ny] = {x, y};
                return true;    
            }
    }
    return false;
}


void solve(){
    cin >> n >> m;
    for(int i = 1; i <= m; i++){
        int x, y; cin >> x >> y;
        a[x][y] = 1;
    }
    memset(match, -1, sizeof match);
    int ans = 0;
    
    // 遍历所有格子，将 (i+j)%2==1 的作为“左侧”节点尝试匹配
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            if(((i + j) & 1) && !a[i][j]){
                memset(vis, 0, sizeof vis);
                if(dfs(i, j)) ans++;
            }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [P1894 [USACO4.2] 完美的牛栏The Perfect Stall](https://www.luogu.com.cn/problem/P1894)(二分图最大匹配)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 210, M = 4e4 + 10;
int n, m, h[N], e[M], ne[M], idx;
int vis[N], match[N];

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v]) continue;
        vis[v] = 1;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> n >> m;
    memset(h, -1, sizeof h);
    for(int i = 1; i <= n; i++){
        int x; cin >> x;
        for(int j = 1; j <= x; j++){
            int k; cin >> k;
            add(i, k);
        }
    }
    int ans = 0;
    for(int i = 1; i <= n; i++){
        memset(vis, 0, sizeof vis);
        if(dfs(i)) ans++;
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [P2071 座位安排](https://www.luogu.com.cn/problem/P2071)(二分图最大匹配)
N 排座位，2N 个人，每个人有四个座位可选，所以最多 8N 条线
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 4e3 + 10, M = 16e3 + 10;
int n, h[N], e[M], ne[M], idx;
int vis[N], match[N];

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v]) continue;
        vis[v] = 1;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> n;
    memset(h, -1, sizeof h);
    for(int i = 1; i <= 2 * n; i++){
        int x, y; cin >> x >> y;
        add(i, 2 * x); add(i, 2 * x - 1);
        add(i, 2 * y); add(i, 2 * y - 1);
    }
    int ans = 0;
    for(int i = 1; i <= 2 * n; i++){
        memset(vis, 0, sizeof vis);
        if(dfs(i)) ans++;
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [P1129 [ZJOI2007] 矩阵游戏](https://www.luogu.com.cn/problem/P1129)(二分图最大匹配)
**通过手动模拟，可以发现：** 无论经过多少次交换，原本存在于该行的元素一定还在该行（只是顺序不同），原本存在于该列上的元素一定还在该列（只是顺序不同）。
**所以题目可转化为：** 能不能找到 $n$ 个互相不同行同列的点。
那我们可以建一个二分图，左边是行，右边是列，如果一个点是黑色的，就从左边连右边，求最大匹配，看是否为 $n$ 。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 200 + 10, M = 4e4 + 10;
int n, h[N], e[M], ne[M], idx;
int vis[N], match[N];

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v]) continue;
        vis[v] = 1;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> n;
    idx = 0; // 注意初始化，清空
    memset(h, -1, sizeof h);
    memset(match, 0, sizeof match);
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++){
            int x; cin >> x;
            if(x) add(i, j);
        }
    int ans = 0;
    for(int i = 1; i <= n; i++){
        memset(vis, 0, sizeof vis);
        if(dfs(i)) ans++;
    }
    cout << (ans == n ? "Yes" : "No") << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    cin >> T;
    while(T--) solve();
    return 0;
}
```

## [P2055 [ZJOI2009] 假期的宿舍](https://www.luogu.com.cn/problem/P2055)(二分图最大匹配)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 60, M = 25e2 + 10;
int n, vec[N], ok[N], h[N], e[M], ne[M], idx;
// vec 记录是否本校学生 1是/0不是
// ok 记录是否回家 1回/0不回
int vis[N], match[N];

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v]) continue;
        vis[v] = 1;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> n;
    idx = 0;
    memset(h, -1, sizeof h);
    memset(match, 0, sizeof match);
    memset(ok, 0, sizeof ok);
    int goal = 0; // 需要的床的数量
    for(int i = 1; i <= n; i++) cin >> vec[i];
    for(int i = 1; i <= n; i++){
        cin >> ok[i];
        if((vec[i] && !ok[i]) || !vec[i]) goal++;
    }
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            int x; cin >> x;
            if(vec[i] && ok[i]) continue;
            // 跳过本校回家的学生(不需要床的人)
            if(j == i && vec[i]) add(i, i);
            // 本校学生可以睡自己的床
            if(x && vec[j]) add(i, j);
            // 睡的床必须是本校学生的
        }   
    }
    int ans = 0;
    for(int i = 1; i <= n; i++){
        if((vec[i] && !ok[i]) || !vec[i]){
            // 如果这个人需要床，才会尝试搜索
            memset(vis, 0, sizeof vis);
            if(dfs(i)) ans++;
        }
    }
    cout << (ans == goal ? "^_^" : "T_T") << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    cin >> T;
    while(T--) solve();
    return 0;
}
```

## [P1640 [SCOI2010] 连续攻击游戏](https://www.luogu.com.cn/problem/P1640)(二分图最大匹配)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 1e4 + 10, M = 1e6 + 10;
int n, h[N], e[M << 1], ne[M << 1], idx;
int vis[N], match[M], stamp;
// stamp作为时间戳，节省memset vis的时间复杂度

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> n;
    memset(h, -1, sizeof(h));
    for(int i = 1; i <= n; i++){
        int x, y; cin >> x >> y;
        add(x, i); add(y, i);
    }
    int ans = 0;
    for(int i = 1; i <= 1e4; i++){
        stamp++;
        if(dfs(i)) ans++;
        else break; // 找不到匹配的就退出
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [P2319 [HNOI2006] 超级英雄](https://www.luogu.com.cn/problem/P2319)(二分图最大匹配)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 1e3 + 10, M = 2e3 + 10;
int n, m, h[N], e[M], ne[M], idx;
int vis[N], match[N], stamp, ok[N];
// stamp作为时间戳，节省memset vis的时间复杂度
// ok[i]: 记录问题i 使用的锦囊妙计的编号

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            ok[u] = v;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> n >> m;
    memset(h, -1, sizeof h);
    for(int i = 1; i <= m; i++){
        int x, y; cin >> x >> y;
        add(i, x); add(i, y);
    }
    int ans = 0;
    for(int i = 1; i <= m; i++){
        stamp++;
        if(dfs(i)) ans++;
        else break;
    }
    cout << ans << endl;
    for(int i = 1; i <= ans; i++)
        cout << ok[i] << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [P2756 飞行员配对方案问题](https://www.luogu.com.cn/problem/P2756)(二分图最大匹配)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 110, M = 2510;
int n, m, h[N], e[M], ne[M], idx;
int vis[N], match[N], ok[N], stamp;
// ok[i]: 记录外籍飞行员i的搭档编号

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            ok[u] = v;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> m >> n;
    memset(h, -1, sizeof h);
    int x, y;
    while(cin >> x >> y, x != -1 && y != -1){
        add(x, y);
    }
    int ans = 0;
    for(int i = 1; i <= m; i++){
        stamp++;
        if(dfs(i)) ans++;
    }
    cout << ans << endl;
    for(int i = 1; i <= n; i++)
        if(ok[i]) cout << i << ' ' << ok[i] << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [P2526 [SHOI2001] 小狗散步](https://www.luogu.com.cn/problem/P2526)(二分图最大匹配)(省选/NOI−)
**这道题的关键在构图**
根据题意得知，每次狗在主人相遇之前最多去一个景点。那我们不妨枚举所有的景点，判断狗从上一个相遇点出发，经过这个景点，最后是否比主人先到达下一个相遇点。
如果先到达，那我们就把上一个相遇点与这个景点连一条边。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define pii pair<int, int>
const int N = 210, M = 1e4 + 10;
int n, m, h[N], e[M], ne[M], idx;
int vis[N], match[N], stamp, ok[N];
// ok[i]: 从相遇点离开后去的景点下标
pii cnt[N];
// cnt记录每个点的坐标

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(!match[v] || dfs(match[v])){
            match[v] = u;
            ok[u] = v;
            return true;
        }
    }
    return false;
}

long double calc(pii a, pii b){
    return sqrtl((a.first - b.first) * (a.first - b.first)
        + (a.second - b.second) * (a.second - b.second));
}

void solve(){
    cin >> n >> m;
    memset(h, -1, sizeof h);
    for(int i = 1; i <= n; i++){
        int x, y; cin >> x >> y;
        cnt[i] = {x, y};
    }
    for(int i = 1; i <= m; i++){
        int x, y; cin >> x >> y;
        cnt[n + i] = {x, y};
        for(int j = 1; j < n; j++){
            if(2 * calc(cnt[j], cnt[j + 1]) >= 
                calc(cnt[j], cnt[n + i]) + calc(cnt[j + 1], cnt[n + i]))
                add(j, n + i);
        }
    }
    int ans = 0; // 最多可以参观多少个景点
    for(int i = 1; i <= n; i++){
        stamp++;
        if(dfs(i)) ans++;
    }
    cout << n + ans << endl;
    for(int i = 1; i <= n; i++){
        cout << cnt[i].first << ' ' << cnt[i].second << " \n"[i == n];
        if(ok[i]) cout << cnt[ok[i]].first << ' ' << cnt[ok[i]].second << ' ';
    }
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [P1963 [NOI2009] 变换序列](https://www.luogu.com.cn/problem/P1963)(二分图最大匹配)(字典序最小匹配)(省选/NOI−)
**本题关键点：字典序最小匹配**
1. 建图：
```cpp
int y1 = (n + i - x) % n;
int y2 = (n + i + x) % n;
```
代表两个合法目标点。注意有可能 `y1 == y2`，此时只加一条边。
为了使得匹配顺序优先匹配编号小的右侧点（保证字典序小），在加边的时候倒过来加：
```cpp
if(y1 < y2) swap(y1, y2); // 把小编号的边最后加上，先被访问
add(i, y1);
add(i, y2);
```
2. 字典序最小匹配的 dfs 顺序：
```cpp
for(int i = n - 1; i >= 0; i--)
dfs(i);
```
倒序处理左侧点，这样编号小的点优先匹配目标编号小的点。

**完整代码：**
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 1e4 + 10, M = 2e4 + 10;
int n, h[N], e[M], ne[M], idx;
int vis[N], match[N], ok[N], stamp;

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(vis[v] == stamp) continue;
        vis[v] = stamp;
        if(match[v] == -1 || dfs(match[v])){
            match[v] = u;
            ok[u] = v;
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> n;
    memset(h, -1, sizeof h);
    memset(match, -1, sizeof match);
    // 因为此题下标从 0 开始，所以未匹配时初始化为 -1

    for(int i = 0; i < n; i++){
        int x; cin >> x;
        int y1 = (n + i - x) % n;
        int y2 = (n + i + x) % n;
        if(y1 == y2) add(i, y1);
        else{
            if(y1 < y2) swap(y1, y2);
            // 确保先add编号大的，这样在遍历时就会从编号小的开始
            add(i, y1);
            add(i, y2);
        }        
    }
    int ans = 0;
    for(int i = n - 1; i >= 0; i--){
	    // 逆序遍历，确保字典序最小
        stamp++;
        if(dfs(i)) ans++;
    }
    if(ans != n) return void(cout << "No Answer" << endl);
    for(int i = 0; i < n; i++)
        cout << ok[i] << " \n"[i == n - 1];
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```

## 持续更新中