---
title: 二分图（从入门到入土）
date: 2025-05-19 18:59:07
tags:
    - 二分图
categories:
    - 算法笔记
---

# 二分图判定
## 什么是二分图？
**二分图：** 节点由两个集合组成，且两个集合内部没有边的图。换言之，存在一种方案，将节点划分成满足以上性质的两个集合。
—— OI-wiki
![](/images/二分图示例.png)
如图，在一个图中，如果能把点分为**两个顶点集**，使**每个集合中，没有两个点有连边**。
也就是说，**边只会连接两个点集**。
## 如何判定二分图？
**存在定理：一张无向图是二分图,当且仅当图中不存在奇环(长度为奇数的环)**
**根据该定理**，可以以染色法进行二分图的判定。主体思想为：尝试用黑白两种颜色标记图中的结点，当一个结点被标记后，它的所有相邻结点应该被标记与它相反的颜色。若标记过程中产生冲突，则说明图中存在奇环。二分图染色一般基于DFS实现，时间复杂度为$\mathcal O(n+m)$
**伪代码如下：**
```cpp
void dfs(int x,int color){
	赋值v[x] <-- color
	对于与x相连的每条无向边(x,y)
	if v[y]=0 then
		dfs(y,3-color)
	else if v[y]=color then 
		判定无向图不是二分图,算法结束
	}

在主函数中
	for i <-- 1 to n
		if(v[i]=0)then dfs(i,1)
	判定无向图是二分图
```
## [P1330 封锁阳光大学](https://www.luogu.com.cn/problem/P1330)(二分图判定)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 1e4 + 10, M = 2e5 + 10;
int n, m, h[N], e[M], ne[M], idx, col[N];
array<int, 2> sum;

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

void dfs(int u, int vis){
    col[u] = vis;
    sum[vis & 1]++;
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(col[v]){
            if(col[v] == col[u]){
                cout << "Impossible" << endl;
                exit(0);
            }
        }else dfs(v, 3 - vis);
    }
}

void solve(){
    cin >> n >> m;
    fill(h + 1, h + n + 1, -1);
    for(int i = 1; i <= m; i++){
        int a, b; cin >> a >> b;
        add(a, b);
        add(b, a);
    }
    int ans = 0;
    for(int i = 1; i <= n; i++){
        sum = {0, 0};
        if(!col[i]) dfs(i, 1);
        ans += min(sum[0], sum[1]);
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```

## [P1525 [NOIP 2010 提高组] 关押罪犯](https://www.luogu.com.cn/problem/P1525)(二分答案+ 二分图判定)(可用并查集)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 2e4 + 10, M = 2e5 + 10;
int n, m, a[M], b[M], c[M], id[M];
int h[N], e[M], ne[M], idx;
int col[N];
int ok;

void add(int u, int v){
    e[idx] = v;
    ne[idx] = h[u];
    h[u] = idx++;
}

void dfs(int u, int vis){
    col[u] = vis;
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(col[v]){
            if(col[u] == col[v])
                return void(ok = 0);
        }else dfs(v, 3 - vis);
    }
}

bool check(int pos){
    idx = 0;
    fill(h + 1, h + n + 1, -1);
    for(int i = pos; i <= m; i++){
        int j = id[i];
        add(a[j], b[j]);
        add(b[j], a[j]);
    }
    ok = 1;
    fill(col + 1, col + n + 1, 0);
    for(int i = 1; i <= n && ok; i++)
        if(!col[i]) dfs(i, 1);
    return ok;
}

void solve(){
    cin >> n >> m;
    for(int i = 1; i <= m; i++){
        cin >> a[i] >> b[i] >> c[i];
        id[i] = i;
    }
    sort(id + 1, id + m + 1, [&](int i, int j){
        return c[i] < c[j];
    });
    int l = 1, r = m + 1;
    while(l < r){
        int mid = (l + r) >> 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    cout << c[id[l - 1]] << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```
## [CF19E. Fairy](https://codeforces.com/contest/19/problem/E)(树上差分 + 二分图判定)(2900)
**解决的问题： 在一个无向图中，找出所有「删除后能使图变成二分图（无奇环）」的边。**
**时间复杂度：**
- 建图 + DFS：$\mathcal O(n + m)$
- 最后枚举所有边判断：$\mathcal O(m)$
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define vi vector<int>
const int N = 2e5 + 10, M = 4e5 + 10;
int n, m, h[N], e[M], ne[M], eid[M], idx;
// eid[idx]: 当前有向边对应的「原始边编号」（1…m）

void add(int a, int b, int id){
    eid[idx] = id;
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

int dep[N], p[N], fl[N], c1[N], c2[N], cnt_odd = 0;
// —— DFS 及差分数组准备 ——
// dep[u]: 深度（根节点深度为 1）
// p[u]: 进入 u 时所用的「原始边编号」
// fl[id]: 标记原始编号为 id 的边是否为树边
// c1[id], c2[id]: 差分数组，分别统计「参与奇环」和「参与偶环」的次数
// cnt_odd: 全局奇环总数


/*
DFS 遍历，构造生成树并统计基环奇偶性
u   当前节点
fa  父节点
pre 从 fa → u 使用的有向边下标（根节点传 -1）
 */
void dfs(int u, int fa, int pre){
    dep[u] = dep[fa] + 1;
    if(pre != -1) p[u] = eid[pre]; // 记录进 u 时的「原始边编号」
    for(int i = h[u]; ~i; i = ne[i]){ // 遍历 u 的所有出边
        int v = e[i];
        if(i == (pre ^ 1)) continue; // 跳过回到父节点时的那条反向边
        if(!dep[v]){ // 树边  
            dfs(v, u, i);
            fl[eid[i]] = 1; // 标记这条原始边为树边
            // 把子树传上来的差分信息累加到「进 u 的那条树边」上
            if(pre != -1){
                c1[p[u]] += c1[eid[i]];
                c2[p[u]] += c2[eid[i]];
            }
        }else if(dep[u] > dep[v]){
            // —— 回边 —— 构成一个基环
            int len = dep[u] - dep[v] + 1;
            if(len & 1){ // 奇环
                c1[eid[i]]++; // 回边自身 +1
                if(pre != -1) c1[p[u]]++; // 从 u 往上差分
                if(p[v]) c1[p[v]]--; // 到 v 停止
                cnt_odd++;
            }else{ // 偶环
                c2[eid[i]]++;
                if(pre != -1) c2[p[u]]++;
                if(p[v]) c2[p[v]]--;
            }
        }
    }
}

void solve(){
    cin >> n >> m;
    fill(h + 1, h + n + 1, -1);
    for(int i = 1; i <= m; i++){
        int u, v; cin >> u >> v;
        add(u, v, i); add(v, u, i);
    }
    for(int i = 1; i <= n; i++){
        if(!dep[i]) dfs(i, 0, -1);
    }
    vi ans;
    if(cnt_odd == 0){
        // 原图已是二分图：任意一条边都可删除
        for(int i = 1; i <= m; i++)
            ans.emplace_back(i);
    }else{
        // 存在奇环，按树边/回边条件筛选
        for(int i = 1; i <= m; i++){
            if(fl[i]){
                // 树边：必须切断所有奇环且不能破坏任何偶环
                if(c1[i] == cnt_odd && c2[i] == 0)
                    ans.emplace_back(i);
            }else{
                // 回边：仅当全局只有这 1 条奇环，且它就是这条边
                if(cnt_odd == 1 && c1[i] == 1)
                    ans.emplace_back(i);
            }
        }
    }
    cout << ans.size() << endl;
    for(auto x : ans) cout << x << " \n"[x == ans.back()];
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```

# 二分图最大匹配
## 持续更新中...